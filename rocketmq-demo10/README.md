# RocketMQ二次封装


## 为什么要二次封装

一个完整的消息传递链路从生产到消费应包括：准备消息、发送消息、记录消息日志、处理发送失败、记录接收消息日志、处理业务逻辑、异常处理和异常重试 等步骤。

虽然使用原生RocketMQ可以完成这些动作，但每个生产者和消费者都需要编写大量重复的代码来完成相同的任务，这就是需要进行二次封装的原因。

通过二次封装，生产者只需准备好消息实体并调用封装后的工具类发送，而消费者只需处理核心业务逻辑，其他公共逻辑会得到统一处理。

本文提到的二次封装不是指对源代码进行封装，而是针对工具的原始使用方式进行的封装。



<br>
<br>


## 封装的抽离点

对于二次封装，其中最主要的就是找出该框架在日常使用中所出现的大部分涉及到的操作，然后找出变化操作和不变化操作RocketMQ日常使用主要场景为例：

- 发送消息阶段：准备需要发送的消息、发送消息、记录原始消息日志、发送失败处理、可靠性处理
- 消费消息阶段：记录接收消息日志、业务处理、业务日志记录、异常处理、异常重试、异常通知、死信处理

提取变化点和不变化点（可以抽取为公共处理的场景）


<br>


### 发送消息阶段：

- 变化点：准备需要发送的消息
- 不变化点：发送消息、记录原始消息日志、发送失败处理、可靠性处理


<br>



### 消费消息阶段

- 变化点：业务处理、业务日志记录
- 不变化点：记录接收消息日志、异常处理、异常重试、异常通知、死信处理
- 抽取后的复杂度：对于新加一个消费者，只需要处理业务相关三个场景（准备需要发送的消息、业务处理、业务日志记录），剩下的场景只需要封装一次就可以

从上可以看到，对于RocketMQ的使用，大部分场景都是可以抽离成一个公共的方法处理，只有业务级的需要自己处理，所以如果我们把不变化场景抽取后，每个同事只需要写自己业务相关部分即可。
