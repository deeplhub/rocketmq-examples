# RocketMQ二次封装


二次封装可以提供更多的功能和更简洁的使用方式。


<br>
<br>


## 封装的抽离点

对于二次封装，其中最主要的就是找出该框架在日常使用中所出现的大部分涉及到的操作，然后找出变化操作和不变化操作RocketMQ日常使用主要场景为例：

- 发送消息阶段：准备需要发送的消息、发送消息、记录原始消息日志、发送失败处理、可靠性处理
- 消费消息阶段：记录接收消息日志、业务处理、业务日志记录、异常处理、异常重试、异常通知、死信处理

提取变化点和不变化点（可以抽取为公共处理的场景）


<br>


### 发送消息阶段：

- 变化点：准备需要发送的消息
- 不变化点：发送消息、记录原始消息日志、发送失败处理、可靠性处理


<br>



### 消费消息阶段

- 变化点：业务处理、业务日志记录
- 不变化点：记录接收消息日志、异常处理、异常重试、异常通知、死信处理
- 抽取后的复杂度：对于新加一个消费者，只需要处理业务相关三个场景（准备需要发送的消息、业务处理、业务日志记录），剩下的场景只需要封装一次就可以

从上可以看到，对于RocketMQ的使用，大部分场景都是可以抽离成一个公共的方法处理，只有业务级的需要自己处理，所以如果我们把不变化场景抽取后，每个同事只需要写自己业务相关部分即可。
